# syx
To run:
- Open the solution.
- Select Win32.App as the startup project.
- Enter the following as command arguments in Win32.App project settings for running through visual studio `projectRoot=D:\syx\syx\data loadScene=D:\syx\syx\data\scene.json`

# Communication between systems
Systems should be able to replicate the state they care about via subscribing to relevant messages in the message queue. At the moment systems can still access other systems directly, but ultimately this should  be phased out in favor of improving message channels to the point that it's easy to request whatever is needed from other systems. All messages are pushed to a global message queue that is swapped every frame. This means any messages sent during a frame will be processed the next frame. Whenever any state is changed that any other system may care about, like Transform, messages should be used to request the change to state, then the message handler on the relevant system should apply the change. If desired, the system could also proactively apply the change and ignore messages from itself.

Currently Graphics and Physics systems are listening to transform events as well as modifications to the Renderable and Physics component properties respectively. They use this to fill their local object maps. The LuaGameSystem is the only system that keeps track of all components on all objects, for the purposes of making them available to scripts. It would currently be difficult to replicate state if a system conditionally started listening for events, as there's currently no way to query for all parts of a game object.

# LuaGameSystem
This holds all game objects so they can be referenced by scripts, and is responsible for running said scripts. During a gameplay update script contexts are batched between multiple threads. Each has immutable access to the game objects, and sends messages when it wants to change properties on objects, which will apply next frame. I will likely introduce thread local state so that within a context the frame gap is not visible if a property is set then immediately retreived. This is currently what happens for adding components, but should be extended for property modifications as well.

Metadata about types is expressed through Lua::Node, which wraps the type itself, as well as any operation that needs to be done on it like construction, destruction, and assigment. This is what is used to simplify the sending of property changes through messages. All relevant properties should be expressed via Lua Nodes in MyComponent::getTypeInfo. This builds a tree that can which can be traversed via pointer offsets to compute differences and serialize them to a buffer. So to send message that requests a change of a property on a component, you can make a copy of the component, change the property, compute the diff of the two using the Lua::Node, then serialize the new values into the SetComponentPropsEvent with the diff id which can be used to only apply the relevant changes on the other end. This is in part to protect against multiple events modifying the same Component in the same frame. If they modify different properties, then they won't stomp each-other because the diff will only apply to the single property that was changed instead of the entire component. If two events set the same component then of course it's a race condition. The **ComponentPublisher** formalizes this process within LuaGameSystem to help discourage accidental unsafe modification of the objects outside of the message loop.

This metadata is also used to populate default editor widgets for well known types, and additional context can be added by attaching custom editor information to the property registration.

# Loading assets
Assets are currently loaded by registering an AssetLoader which corresponds to a particular AssetType and file extension. In code then these assets can be retrieved via access to the AssetRepo system. An asset handle will be available immediately while the asset load process is known via an enum on the asset. This process is a bit clunky at the moment, lacking a reasonable error mechanism for missing asseets. This would benefit from events when loading finishes and possibly a future as well for the asset handle. Or maybe both could be accomplished by creating a message wrapper that wraps the awaiting of a message in a future.

# Saving and loading scenes
The lua nodes of all objects in LuaGameSystem are used to serialize all properties of a scene to an executable lua file. When saving the file the system notes all assets that are needed and puts then in a separate section of the file so that the assets can be loaded as part of loading the scene.

# Exposing methods to the scripting layer
Each component has a virtual openLib function that can declare all the members of what is exposed about this component to the scripting layer. The object's properties are automatically exposed as `self.propertyName = value` by the information provided by the Component's `Lua::Node`s. Additional methods are exposed manually with function pointers. `self` will result in the `this` pointer being availabe on the lua stack which can be retreived with `Component::_checkSelf`. This returns a `ComponentPublisher`, reinforcing the idea that the game objects should be immutable while scripts are running, so any methods that wish to modify logic should use the publisher to send messages that will be applied next frame. The heavy coupling with lua for this is not great, but coming up with an abstraction layer is a low priority for me.